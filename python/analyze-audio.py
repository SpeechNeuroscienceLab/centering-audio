# import statements
import numpy as np
import csv
import figures as fig
import matplotlib.pyplot as plt
import tables
import tests

# TODO: parse input table from file, if provided. Otherwise, request path. 

verbose = True

def printv(message):
    if verbose:
        print(message)

printv("Verbose enabled")

# temporary path to speed up development
input_path = "/storage/Organizations/UCSF/tables-and-figures/analyze_audio.csv"
output_path = "/storage/Organizations/UCSF/tables-and-figures/post-analysis/"


# TODO: streamlined way to select figures, tables, tests as well as plotting options
plotting_list = ["group-starting-pitches-histogram", "group-ending-pitches-histogram"]
all_figures = True

# we want to move away from the legacy format as fast as we can. As a result, the legacy script only contains one pass. For analysis that requires many passes, we need to use this script.  
table_list = ["run-stats-marked-tercile"]
all_tables = False

test_list = []
all_tests = True

# figures are always saved to disk. show_figures = True will also plot them on this machine
show_figures = True


printv("initialized settings")



# this is the datatable that was created by the "convert file" utility.
# The format generated by convert_from_legacy will be written in the README in the future

read_labels = False

# initialize numpy arrays
group_list = [] # a list of group names. Starts at 0, index is the group number. 
subject_list = [] # a list of subject names. This allows us to map subject numbers to names in post

# trial data: group num | subject num | start_point | end_point | centering | starting_deviation | ending_deviation | tercile number
trial_data = []# trial_wise list of lists. Upon processing, convert to numpy array.

printv("reading input csv file...")

with open(input_path, newline='') as datacsv:
    # process data here
    # Terciles: each trial needs to be labeled with which tercile it belongs in
    #
    # Each of the following metrics are to be calculated per subject, per tercile per subject, peripheral trials only
    # Average startpoint, Average endpoint, Average centering, Average start deviation, Average end deviation
    for row in csv.reader(datacsv):
        # for each line
        if not read_labels:
            # anything that should be done with the labels can be done here
            read_labels = True 
            continue
        # otherwise, extract data
        if not row[0] in group_list:
            group_list.append(row[0])
            subject_list.append([])
        if not row[1] in subject_list[group_list.index(row[0])]:
            subject_list[group_list.index(row[0])].append(row[1])
        trial_data.append([group_list.index(row[0]),subject_list[group_list.index(row[0])].index(row[1]),float(row[2]),float(row[3]),float(row[4]),np.abs(float(row[2])),np.abs(float(row[3])), 0])

printv("reading csv complete")
        

# because we rely on many overall metrics which rely on all the trials (terciles, for example, and sorting) 
# we need to wait until all the data is processed before we can generate any figures.

trial_data = np.array(trial_data) # trial data is converted to numpy array

terciles_data = []
peripheral_terciles_data = []

printv("analyzing terciles...")

# now that we have the numpy array, we can begin more tercile analysis. 
# for now, calculate using starting position. Change required?

for group_idx in range(0, len(group_list)):
    for subject_idx in range(0, len(subject_list[group_idx])):
        # for each subject in each group
        subject_trial_data = trial_data[np.logical_and(trial_data[:, 0] == group_idx, trial_data[:, 1] == subject_idx)]
        subject_trial_data = subject_trial_data[:, 0:7]
        
        labeled_trial_data = np.append(subject_trial_data, np.arange(subject_trial_data.shape[0]).reshape(subject_trial_data.shape[0], 1), 1)

        # trial data contains only the rows that are in the trial
        trials_by_start = labeled_trial_data[labeled_trial_data[:, 2].argsort()]

        # when in doubt, the peripheral trials should be equally sized
        tercile_size = int(trials_by_start.shape[0]/3)

        tercile_map = np.zeros([trials_by_start.shape[0], 1])
        tercile_map[0:tercile_size] = -1
        tercile_map[trials_by_start.shape[0] - tercile_size:trials_by_start.shape[0]] = 1
        
        terciles_trial_data = np.append(trials_by_start, tercile_map, 1)

        # resort data
        terciles_trial_data = terciles_trial_data[terciles_trial_data[:, 7].argsort()]
        terciles_trial_data = np.delete(terciles_trial_data, 7, 1)

        # replace old data
        trial_data[np.logical_and(trial_data[:, 0] == group_idx, trial_data[:, 1] == subject_idx)] = terciles_trial_data

        subject_tercile_data = []
        # create tercile level data
        # tercile data will have 3 rows
        for tercile_idx in range(-1, 2):
            # get the tercile
            tercile_data = terciles_trial_data[terciles_trial_data[:, 7] == tercile_idx]
            subject_tercile_data.append(np.mean(tercile_data, axis=0))
        # append subject_tercile_data to tercile_data
        if len(terciles_data) <= group_idx:
            terciles_data.append([])
            peripheral_terciles_data.append([])

        terciles_data[group_idx].append(subject_tercile_data)

        # export peripheral trials only
        peripheral_subject_data = np.mean(terciles_trial_data[terciles_trial_data[:, 7] != 0], axis=0)
        # delete the tercile number, the starting point and ending point.... not useful at the peripheral tercile level
        peripheral_subject_data = np.delete(peripheral_subject_data, [2, 3, 7])
        
        peripheral_terciles_data[group_idx].append(peripheral_subject_data)

    peripheral_terciles_data[group_idx] = np.array(peripheral_terciles_data[group_idx])

printv("tercile analysis complete")

######################### TESTS ##########################
printv("running tests...")
if "test-of-normality" in test_list or all_tests:
    printv("running test of normality")
    tests.test_of_normality(group_list, trial_data)


printv("tests complete.")
######################### TABLES #############################

printv("generating tables...")

if "run-stats-marked-tercile" in table_list or all_tables:
    printv("generating run_stats table with terciles")
    tables.run_stats_marked_tercile(group_list, subject_list, trial_data, output_path)

printv("table generation complete")

######################### PLOTTING ###############################
printv("plotting figures...")

plt.style.use('dark_background')

# plt.xkcd()



if "subject-tercile-arrows" in plotting_list or all_figures:
    printv("plotting subject tercile arrows")
    fig.subject_tercile_arrows(group_list, subject_list, terciles_data)
if "group-centering-bars" in plotting_list or all_figures:
    printv("plotting group centering bars")
    fig.group_centering_bars(group_list, trial_data)
if "group-starting-deviations-bars" in plotting_list or all_figures:
    printv("plotting group starting deviations bars")
    fig.group_starting_deviations_bars(group_list, trial_data)
if "group-ending-deviations-bars" in plotting_list or all_figures:
    printv("plotting group ending deviations bars")
    fig.group_ending_deviations_bars(group_list, trial_data)
if "group-starting-pitches-histogram" in plotting_list or all_figures:
    printv("plotting group starting pitches histogram")
    fig.group_starting_pitches_histogram(group_list, trial_data)
if "group-ending-pitches-histogram" in plotting_list or all_figures:
    printv("plotting group ending pitches histogram")
    fig.group_ending_pitches_histogram(group_list, trial_data)

printv("saving figures to disk....")
fig.save_figs(output_path)
printv("done.")

if show_figures:
    plt.show() # show all plots at once after generation

