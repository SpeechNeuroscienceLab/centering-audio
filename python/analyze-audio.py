# import statements
import numpy as np
import csv
import figures as fig
import matplotlib.pyplot as plt
import tables
import tests
import sys

# Parse args
args = sys.argv

input_path = ""
output_path = ""

verbose = False

all_figures = True
plotting_list = []

all_tables = True
table_list = []

all_tests = True
test_list = []

show_figures = True
print_test_results = True

plot_theme = "dark_background"

remove_outliers = True
OUTLIER_STD = 1

def help():
    print("ARGUMENT OVERVIEW")
    print("-i --input=INPUT \t\t use INPUT as the input for analysis")
    print("-o --output=OUTPUT \t\t write all results to the folder at path OUTPUT")
    print("-v --verbose \t\t\t enables verbose output mode")
    print("-f --figures=FIGNAMES ... \t generates figures listed out after the figures flag, separated by spaces")
    print("-b --tables=TABLENAMES ... \t generates tables listed out after the tables flag, separated by spaces")
    print("-t --tests=TESTNAMES ... \t runs tests listed out after the tests flag, separated by spaces")
    print("--include-outliers \t\t includes outliers")
    print("--hide-figures \t\t\t disables display of figures upon save to disk")
    print("--hide-tests \t\t\t disables display of test results upon save to disk")
    print("--hide \t\t\t\t does not display test results or figures: alias of --hide-figures --hide-tests")
    print("-h --help \t\t\t prints this help message")

for argx in range(1, len(args)):
    arg = str(args[argx])
    # the only required argument is the path argument
    if arg == "-i" or arg == "--input":
        input_path = str(args[argx + 1])
    elif arg == "-o" or arg == "--output":
        output_path = str(args[argx + 1])
    elif arg == "-v" or arg == "--verbose":
        verbose = True
    elif arg == "-f" or arg == "--figures":
        all_figures = False
        for listable in range(argx + 1, len(args)):
            if(args[listable] == "-"):
                break
            else:
                plotting_list.append(args[listable])
    elif arg == "-b" or arg == "--tables":
        all_tables = False
        for listable in range(argx + 1, len(args)):
            if(args[listable] == "-"):
                break
            else:
                table_list.append(args[listable])
    elif arg == "-t" or arg == "--tests":
        all_tests = False
        for listable in range(argx + 1, len(args)):
            if(args[listable] == "-"):
                break
            else:
                test_list.append(args[listable])
    elif arg == "--hide-figures":
        show_figures = False
    elif arg == "--hide-tests":
        print_test_results = False
    elif arg == "--hide":
        print_test_results = False
        show_figures = False
    elif arg == "-h" or arg == "--help":
        help()
        exit()
    elif arg == "--theme":
        plot_theme = str(args[argx + 1])
    elif arg == "--include-outliers":
        remove_outliers = False

if input_path == "":
    print("An input path is required.")
    exit()


def printv(message):
    if verbose:
        print(message)

printv("verbose enabled")


if output_path == "":
    output_path ="/".join(input_path.split("/")[0:len(input_path.split("/")) - 1]) + "/post-analysis/"
    printv("Inferring output path:" + output_path)

# we want to move away from the legacy format as fast as we can. As a result, the legacy script only contains one pass. For analysis that requires many passes, we need to use this script.  

# figures are always saved to disk. show_figures = True will also plot them on this machine

printv("initialized settings")



# this is the datatable that was created by the "convert file" utility.
# The format generated by convert_from_legacy will be written in the README in the future

read_labels = False

# initialize numpy arrays
group_list = [] # a list of group names. Starts at 0, index is the group number. 
subject_list = [] # a list of subject names. This allows us to map subject numbers to names in post

# trial data: group num | subject num | start_point | end_point | centering | starting_deviation | ending_deviation | tercile number
trial_data = []# trial_wise list of lists. Upon processing, convert to numpy array.

printv("reading input csv file...")

with open(input_path, newline='') as datacsv:
    # process data here
    # Terciles: each trial needs to be labeled with which tercile it belongs in
    #
    # Each of the following metrics are to be calculated per subject, per tercile per subject, peripheral trials only
    # Average startpoint, Average endpoint, Average centering, Average start deviation, Average end deviation
    for row in csv.reader(datacsv):
        # for each line
        if not read_labels:
            # anything that should be done with the labels can be done here
            read_labels = True 
            continue
        # otherwise, extract data
        if not row[0] in group_list:
            group_list.append(row[0])
            subject_list.append([])
        if not row[1] in subject_list[group_list.index(row[0])]:
            subject_list[group_list.index(row[0])].append(row[1])
        trial_data.append([group_list.index(row[0]),subject_list[group_list.index(row[0])].index(row[1]),float(row[2]),float(row[3]),float(row[4]),np.abs(float(row[2])),np.abs(float(row[3])), 0])

printv("reading csv complete")
        

# because we rely on many overall metrics which rely on all the trials (terciles, for example, and sorting) 
# we need to wait until all the data is processed before we can generate any figures.

trial_data = np.array(trial_data) # trial data is converted to numpy array

terciles_data = []

printv("analyzing terciles...")

# now that we have the numpy array, we can begin more tercile analysis. 
# for now, calculate using starting position. Change required?

for group_idx in range(0, len(group_list)):
    for subject_idx in range(0, len(subject_list[group_idx])):
        # for each subject in each group
        subject_trial_data = trial_data[np.logical_and(trial_data[:, 0] == group_idx, trial_data[:, 1] == subject_idx)]
        subject_trial_data = subject_trial_data[:, 0:7]
        
        labeled_trial_data = np.append(subject_trial_data, np.arange(subject_trial_data.shape[0]).reshape(subject_trial_data.shape[0], 1), 1)

        # trial data contains only the rows that are in the trial
        trials_by_start = labeled_trial_data[labeled_trial_data[:, 2].argsort()]

        # when in doubt, the peripheral trials should be equally sized
        tercile_size = int(trials_by_start.shape[0]/3)

        tercile_map = np.zeros([trials_by_start.shape[0], 1])
        tercile_map[0:tercile_size] = -1
        tercile_map[trials_by_start.shape[0] - tercile_size:trials_by_start.shape[0]] = 1
        
        terciles_trial_data = np.append(trials_by_start, tercile_map, 1)

        # resort data
        terciles_trial_data = terciles_trial_data[terciles_trial_data[:, 7].argsort()]
        terciles_trial_data = np.delete(terciles_trial_data, 7, 1)

        # replace old data
        trial_data[np.logical_and(trial_data[:, 0] == group_idx, trial_data[:, 1] == subject_idx)] = terciles_trial_data

        subject_tercile_data = []
        # create tercile level data
        # tercile data will have 3 rows
        for tercile_idx in range(-1, 2):
            # get the tercile
            tercile_data = terciles_trial_data[terciles_trial_data[:, 7] == tercile_idx]
            subject_tercile_data.append(np.mean(tercile_data, axis=0))
        # append subject_tercile_data to tercile_data
        if len(terciles_data) <= group_idx:
            terciles_data.append([])

        terciles_data[group_idx].append(subject_tercile_data)

printv("tercile analysis complete")

printv("purging outliers...")

if(remove_outliers):
    for group_idx in range(0, len(group_list)):
        # for each group, get the group data
        outlier_subjects = [];
        group_tercile_data = terciles_data[group_idx]
        group_trial_data = trial_data[trial_data[:, 0] == group_idx]
        # only observe outliers in the peripheral trials
        observation_terciles = [-1, 1]

        for tercile in observation_terciles:
            # tercile is the value of which tercile we are looking at. 
            # calculate the cutoffs
            tercile_trial_data = group_trial_data[group_trial_data[:, 7] == tercile]
            mean = np.mean(tercile_trial_data[:, 5])
            std = np.std(tercile_trial_data[:, 5])
            tercile_strings = ["lower", "central", "upper"]
            printv(tercile_strings[tercile + 1] + " tercile starting location:")
            printv("mean is " + str(mean) + " and std is " + str(std)) 

            for subject_idx in range(0, len(subject_list[group_idx])):
                # for each subject in the list
                # get the subject start point average for this tercile 
                subject_start = np.abs(terciles_data[group_idx][subject_idx][tercile + 1][2])

                if(subject_start > mean + std * OUTLIER_STD or subject_start < mean - std * OUTLIER_STD):
                    printv("Subject " + subject_list[group_idx][subject_idx] + " from group " + 
                            group_list[group_idx] + " can be considered an outlier (index " + str(subject_idx) + 
                            ") due to its " + str(tercile) + " tercile position")
                    outlier_subjects.append(subject_idx)

        outlier_subjects.sort()

        # actually remove the outlier from trials 
        for outlier_idx in range(0, len(outlier_subjects)):
            outlier = outlier_subjects[outlier_idx]
            # outlier is the index of the outlier in this group
            # remove from trial_data
            trials_to_remove = np.where(np.logical_and((trial_data[:, 0] == group_idx), (trial_data[:, 1] == outlier)))
            np.delete(trial_data, trials_to_remove, axis=0)

            # remove from tercile data
            terciles_data[group_idx].pop(outlier)

            # remove from subject_list
            subject_list[group_idx].pop(outlier)

            # organize remaining data
            printv("successfully removed outlier at index " + str(outlier) + " out of " + str(len(subject_list[group_idx])))

            # renumber trial_data
            for subject_idx in range(outlier, len(subject_list[group_idx])):
                replacement_mask = np.where(np.logical_and((trial_data[:, 0] == group_idx), (trial_data[:, 1] == subject_idx + 1)))
                trial_data[replacement_mask, 1] = subject_idx

                printv("renumbered " + str(subject_idx + 1) + " as " + str(subject_idx))

                # renumber terciles_data
                for tercile_idx in [0, 1, 2]:
                    terciles_data[group_idx][subject_idx][tercile_idx][1] = subject_idx

            # renumber outlier data
            for dec in range(outlier_idx + 1, len(outlier_subjects)):
                outlier_subjects[dec] = outlier_subjects[dec] - 1

printv("Outlier removal complete")


print(len(trial_data[trial_data[:, 0] == 0]))

for group_idx in range(0, len(group_list)):
    printv(str(len(subject_list[group_idx])) + " subjects in Group " + group_list[group_idx])
    printv(subject_list[group_idx])

######################### TESTS ##########################
printv("running tests...")
if "test-of-normality" in test_list or all_tests:
    printv("running test of normality")
    tests.test_of_normality(group_list, trial_data)


printv("tests complete.")
######################### TABLES #############################

printv("generating tables...")

if "run-stats-marked-tercile" in table_list or all_tables:
    printv("generating run_stats table with terciles")
    tables.run_stats_marked_tercile(group_list, subject_list, trial_data, output_path)

printv("table generation complete")


######################### SET SCALES ###############################
printv("Setting scales...")

fig.scales["deviations-bars"] = fig.calculate_deviations_limits(group_list, trial_data)


printv("Scales set successfully")
######################### PLOTTING ###############################
printv("plotting figures...")

if plot_theme == "xkcd":
    plt.xkcd()
else:
    plt.style.use(plot_theme)


if "subject-tercile-arrows" in plotting_list or all_figures:
    printv("plotting subject tercile arrows")
    fig.subject_tercile_arrows(group_list, subject_list, terciles_data)
if "subject-tercile-arrows-with-error" in plotting_list or all_figures:
    printv("plotting subject tercile arrows with error")
    fig.subject_tercile_arrows_with_error(group_list, subject_list, trial_data)
if "group-centering-bars" in plotting_list or all_figures:
    printv("plotting group centering bars")
    fig.group_centering_bars(group_list, trial_data)
if "group-starting-deviations-bars" in plotting_list or all_figures:
    printv("plotting group starting deviations bars")
    fig.group_starting_deviations_bars(group_list, trial_data)
if "group-centering-bars-o2" in plotting_list or all_figures:
    printv("plotting group centering bars (option 2)")
    fig.group_centering_bars_o2(group_list, trial_data)
if "group-ending-deviations-bars" in plotting_list or all_figures:
    printv("plotting group ending deviations bars")
    fig.group_ending_deviations_bars(group_list, trial_data)
if "group-starting-pitches-histogram" in plotting_list or all_figures:
    printv("plotting group starting pitches histogram")
    fig.group_starting_pitches_histogram(group_list, trial_data)
if "group-ending-pitches-histogram" in plotting_list or all_figures:
    printv("plotting group ending pitches histogram")
    fig.group_ending_pitches_histogram(group_list, trial_data)
if "group-pitches-qq" in plotting_list:#TODO: finish qq plot then uncomment #or all_figures:
    printv("plotting group pitches qq plot")
    fig.group_pitches_qq(group_list, trial_data)

printv("saving figures to disk....")
fig.save_figs(output_path)
tests.save_results(output_path)
printv("done.")

if show_figures:
    plt.show() # show all plots at once after generation
if print_test_results:
    tests.print_test_results()

